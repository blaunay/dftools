grammar net.sf.dftools.cdl.Cdl with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate cdl "http://www.sf.net/dftools/cdl/Cdl"

///////////////////////////////////////////////////////////////////////////////
// top-level entity
///////////////////////////////////////////////////////////////////////////////

Module:
	('package' package=QualifiedName ';')?
	(imports += Import)*
	
	( ('component' name=ID component=Component)
	| ('library' name=ID library=Library)
	);
	
Import: 'import' importedNamespace=QualifiedNameWithWildCard ';';

QualifiedName:
	ID ('.' ID)*;

QualifiedNameWithWildCard:
	QualifiedName '.*'?;

	
///////////////////////////////////////////////////////////////////////////////
// Entities
///////////////////////////////////////////////////////////////////////////////


Library:{Library} 
	 '{'
		(types += TypeDecl)*
	'}';

Component:{Component}
	 '(' ')' '{'	
		
		(operator=Operator)?
		
		((interfaces += Interface)
		 |(memories += Memory))*

	'}';

///////////////////////////////////////////////////////////////////////////////
// Component classes
///////////////////////////////////////////////////////////////////////////////

Operator:
	'operator' core=Core;

Interface: 
	'interface' core=Core;
	
Memory: 
	'memory' core=Core;
	
Core: type=[Class|QualifiedName] name=ID '{'
		(fields+=Field)*
	'}';

Field: attribute=[Attribute] '=' value=Expression ';';


///////////////////////////////////////////////////////////////////////////////
// Library classes
///////////////////////////////////////////////////////////////////////////////

Class:
	'class' name=ID  '{'
		((attributes+=Attribute))*
	'}';

Attribute: type=Type name=ID ( '=' default=Expression )? ';';

Enum :
	'enum' name=ID '{' 
		(constants += EConstant)
		(',' (constants += EConstant))*
	 '}';

EConstant : constant=EConstantType;

EConstantType :  Literal | name=ID;

///////////////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////////////

TypeDecl: Class | Enum;

Type: TypeBool | TypeInt | TypeLong | TypeString | TypeRef;

TypeRef: type=[TypeDecl];

TypeBool: name='bool';

TypeInt: name='int';

TypeLong: name='long';

TypeString: name='String';

///////////////////////////////////////////////////////////////////////////////
// Litterals
///////////////////////////////////////////////////////////////////////////////

Literal: LiteralInteger | LiteralString | LiteralBool | LiteralDouble;

LiteralInteger : int=INT;

LiteralString: string=STRING;

LiteralBool : bool=BOOL;

LiteralDouble : double=DOUBLE;

//LiteralEnum : (type=[Enum|QualifiedName] '.')? value=[EConstant] ;

	
terminal BOOL returns ecore::EBoolean: 'true' | 'false';

terminal DOUBLE returns ecore::EDouble :
	('0'..'9')+ '.' ('0'..'9')* (('e'|'E') ('+' | '-')? ('0'..'9')+)?
|	'.' ('0'..'9')+ (('e'|'E') ('+' | '-')? ('0'..'9')+)?
|	('0'..'9')+ ('e'|'E') ('+' | '-')? ('0'..'9')+;

///////////////////////////////////////////////////////////////////////////////
// expressions
///////////////////////////////////////////////////////////////////////////////

Expression:
	ExpressionAnd ({ExpressionBinary.left=current} operator=('||' | 'or') right=ExpressionAnd)*;
ExpressionAnd returns Expression:
	ExpressionBitor ({ExpressionBinary.left=current} operator=('&&' | 'and') right=ExpressionBitor)*;
ExpressionBitor returns Expression:
	ExpressionBitxor ({ExpressionBinary.left=current} operator='|' right=ExpressionBitxor)*;
ExpressionBitxor returns Expression:
	ExpressionBitand ({ExpressionBinary.left=current} operator='^' right=ExpressionBitand)*;
ExpressionBitand returns Expression:
	ExpressionEq ({ExpressionBinary.left=current} operator='&' right=ExpressionEq)*;
ExpressionEq returns Expression:
	ExpressionRelational ({ExpressionBinary.left=current} operator=('=' | '!=') right=ExpressionRelational)*;
ExpressionRelational returns Expression:
	ExpressionShift ({ExpressionBinary.left=current} operator=('<' | '<=' | '>' | '>=') right=ExpressionShift)*;
ExpressionShift returns Expression:
	ExpressionAdditive ({ExpressionBinary.left=current} operator=('<<' | '>>') right=ExpressionAdditive)*;
ExpressionAdditive returns Expression:
	ExpressionMultiplicative ({ExpressionBinary.left=current} operator=('+' | '-') right=ExpressionMultiplicative)*;
ExpressionMultiplicative returns Expression:
	ExpressionExp ({ExpressionBinary.left=current} operator=('*' | '/' | 'div' | 'mod') right=ExpressionExp)*;
ExpressionExp returns Expression:
	ExpressionUnary ({ExpressionBinary.left=current} operator='**' right=ExpressionUnary)*;

ExpressionUnary returns Expression:
	{ExpressionUnary} unaryOperator=('~' | '-' | 'not' | '#') expression=ExpressionPostfix
	| ExpressionPostfix;

ExpressionPostfix returns Expression:
	'(' Expression ')' |
	Literal;
