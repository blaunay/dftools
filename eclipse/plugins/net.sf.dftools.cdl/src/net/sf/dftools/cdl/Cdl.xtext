grammar net.sf.dftools.cdl.Cdl with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate cdl "http://www.sf.net/dftools/cdl/Cdl"

///////////////////////////////////////////////////////////////////////////////
// top-level entity
///////////////////////////////////////////////////////////////////////////////

Module:
	('package' package=QualifiedName ';')?
	(imports += Import)*
	
	( ('component' name=ID component=Component)
	| ('library' name=ID library=Library)
	);
	
Import: 'import' importedNamespace=QualifiedNameWithWildCard ';';

QualifiedName:
	ID ('.' ID)*;

QualifiedNameWithWildCard:
	QualifiedName '.*'?;

	
///////////////////////////////////////////////////////////////////////////////
// Entities
///////////////////////////////////////////////////////////////////////////////


Library:{Library} 
	 '{'
		(types += Decl)*
	'}';
	

Component:{Component}
	 '(' ')' '{'	
		
		(operator=Operator)?
		
		((interfaces += Interface)
		 |(memories += Memory))*

	'}';

///////////////////////////////////////////////////////////////////////////////
// Component classes
///////////////////////////////////////////////////////////////////////////////

Operator:
	'operator' core=Core;

Interface: 
	'interface' core=Core;
	
Memory: 
	'memory' core=Core;
	
Core:
	type=[Class|QualifiedName] name=ID '{'
		(fields+=Field)*
	'}';

// Ref Field 
/*Field: 
	attribute=[Attribute] '=' value=Expression ';' ;*/
	
//Recursive Feild
//Field: 
//	attribute=AttributeRef '=' value=Expression ';' ;

//AttributeRef: attribute=[Attribute] ('.' child=AttributeChild)?  ;

//AttributeChild : attribute=[Attribute] ('.' child=AttributeChild)? ;

//Recursive Feild
Field: 
	domain=Domain '=' value=Expression ';';
	
Domain : 
	PrimaryDomain({DomainCall.left=current}'.'right=PrimaryDomain)* ;

PrimaryDomain returns Domain:
	attribute=[Attribute];
	

///////////////////////////////////////////////////////////////////////////////
// Library classes
///////////////////////////////////////////////////////////////////////////////

Decl: Class | Enum; 

Class :
	'class' name=ID  '{'
		((attributes+=Attribute))*
	'}';

Attribute: type=Type name=ID ( '=' default=Expression )? ';';

Enum :
	'enum' name=ID '{' 
		(constants += EnumLiteral)
		(',' (constants += EnumLiteral))*
	 '}';

EnumLiteral returns Symbol:
 {EnumLiteral} name=ID;
 

///////////////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////////////

Type: TypeBool | TypeInt | TypeLong | TypeString | TypeDecl;

TypeDecl: type=[Decl];

TypeBool: name='bool';

TypeInt: name='int';

TypeLong: name='long';

TypeString: name='String';

///////////////////////////////////////////////////////////////////////////////
// Litterals
///////////////////////////////////////////////////////////////////////////////

Literal: LiteralInteger | LiteralString | LiteralBool | LiteralDouble;

LiteralInteger : int=INT;

LiteralString: string=STRING;

LiteralBool : bool=BOOL;

LiteralDouble : double=DOUBLE;

	
terminal BOOL returns ecore::EBoolean: 'true' | 'false';

terminal DOUBLE returns ecore::EDouble :
	('0'..'9')+ '.' ('0'..'9')* (('e'|'E') ('+' | '-')? ('0'..'9')+)?
|	'.' ('0'..'9')+ (('e'|'E') ('+' | '-')? ('0'..'9')+)?
|	('0'..'9')+ ('e'|'E') ('+' | '-')? ('0'..'9')+;

///////////////////////////////////////////////////////////////////////////////
// expressions
///////////////////////////////////////////////////////////////////////////////

Expression:
	ExpressionAnd ({ExpressionBinary.left=current} operator=('||' | 'or') right=ExpressionAnd)*;
ExpressionAnd returns Expression:
	ExpressionBitor ({ExpressionBinary.left=current} operator=('&&' | 'and') right=ExpressionBitor)*;
ExpressionBitor returns Expression:
	ExpressionBitxor ({ExpressionBinary.left=current} operator='|' right=ExpressionBitxor)*;
ExpressionBitxor returns Expression:
	ExpressionBitand ({ExpressionBinary.left=current} operator='^' right=ExpressionBitand)*;
ExpressionBitand returns Expression:
	ExpressionEq ({ExpressionBinary.left=current} operator='&' right=ExpressionEq)*;
ExpressionEq returns Expression:
	ExpressionRelational ({ExpressionBinary.left=current} operator=('=' | '!=') right=ExpressionRelational)*;
ExpressionRelational returns Expression:
	ExpressionShift ({ExpressionBinary.left=current} operator=('<' | '<=' | '>' | '>=') right=ExpressionShift)*;
ExpressionShift returns Expression:
	ExpressionAdditive ({ExpressionBinary.left=current} operator=('<<' | '>>') right=ExpressionAdditive)*;
ExpressionAdditive returns Expression:
	ExpressionMultiplicative ({ExpressionBinary.left=current} operator=('+' | '-') right=ExpressionMultiplicative)*;
ExpressionMultiplicative returns Expression:
	ExpressionExp ({ExpressionBinary.left=current} operator=('*' | '/' | 'div' | 'mod') right=ExpressionExp)*;
ExpressionExp returns Expression:
	ExpressionUnary ({ExpressionBinary.left=current} operator='**' right=ExpressionUnary)*;

ExpressionUnary returns Expression:
	{ExpressionUnary} unaryOperator=('~' | '-' | 'not' | '#') expression=ExpressionPostfix
	| ExpressionPostfix;

ExpressionAtomic returns Expression:
  {SymbolRef} var=[Symbol|QualifiedName] |
  {LiteralRef} value=Literal;

ExpressionPostfix returns Expression:
	'(' Expression ')' |
	ExpressionAtomic ;
